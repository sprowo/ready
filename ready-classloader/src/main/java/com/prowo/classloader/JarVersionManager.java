package com.prowo.classloader;import java.util.HashMap;import java.util.Map;import java.util.Map.Entry;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 版本控制 */public class JarVersionManager {	public static final String JAR_SUFFIX = ".jar";	private static final String JAR_SPLIT = "-";	private static final Pattern PATTERN_VERSION = Pattern			.compile("^[vV]?\\d\\.\\d$");	private static Map<String, String> getLastVersionMap(String[] fileNames) {		if (fileNames != null && fileNames.length > 0) {			Map<String, String> versions = new HashMap<String, String>();			for (String fileName : fileNames) {				if (fileName.endsWith(JAR_SUFFIX)) {					fileName = fileName.substring(0, fileName.length() - 4);					String fileNameBase = fileName;					String fileNameVersion = "";					int i = fileName.lastIndexOf(JAR_SPLIT);					if (i != -1) {						fileNameVersion = fileName.substring(i + 1);						Matcher matcher = PATTERN_VERSION								.matcher(fileNameVersion);						if (matcher.matches()) {							fileNameBase = fileName.substring(0, i);						} else {							fileNameBase = fileName;							fileNameVersion = "";						}					}					if ((versions.containsKey(fileNameBase) && (""							.equals(fileNameVersion) || fileNameVersion							.compareToIgnoreCase(versions.get(fileNameBase)) > 0))							|| !versions.containsKey(fileNameBase)) {						versions.put(fileNameBase, fileNameVersion);					}				}			}			return versions;		}		return null;	}	/**	 * 获得最新版本的jar列表,没有版本号的(没有release的版本)默认为最新的	 * 警告：除开发环境外，其他环境的需要版本控制的jar都必须是**-版本号.jar 的格式	 *	 * @param fileNames	 *            所有JAR文件	 * @return	 */	public static String[] getLastVersion(String[] fileNames) {		Map<String, String> versions = getLastVersionMap(fileNames);		int length = 0;		if (versions != null && (length = versions.size()) > 0) {			String[] lastVersion = new String[length];			int i = 0;			for (Entry<String, String> version : versions.entrySet()) {				String versionValue = version.getValue();				if ("".equals(versionValue)) {					lastVersion[i++] = version.getKey() + JAR_SUFFIX;				} else {					lastVersion[i++] = version.getKey() + JAR_SPLIT							+ version.getValue() + JAR_SUFFIX;				}			}			return lastVersion;		}		return null;	}	/**	 * 上传的jar对应的最新版本的jar 如果最新版本的jar不是当前上传的jar,返回NULL 反之,返回fileName	 *	 * @param fileNames	 *            已有的jar列表	 * @param fileName	 *            上传的jar	 * @return	 * @throws Exception	 */	public static String getLastVersion(String[] fileNames, String fileName) {		if (!fileName.endsWith(JAR_SUFFIX)) {			return null;		}		int i = fileName.lastIndexOf(JAR_SPLIT);		if (i == -1) {			return fileName;		}		fileName = fileName.substring(0, fileName.length() - 4);		String fileNameVersion = fileName.substring(i + 1);		Matcher matcher = PATTERN_VERSION.matcher(fileNameVersion);		if (matcher.matches()) {			Map<String, String> lastVersionMap = getLastVersionMap(fileNames);			String fileNameBase = fileName.substring(0, i);			if (lastVersionMap.containsKey(fileNameBase)) {				String targetVersion = lastVersionMap.get(fileNameBase);				if ("".equals(fileNameVersion)) {					return fileNameBase + JAR_SUFFIX;				} else if (fileNameVersion.compareTo(targetVersion) >= 0) {					return fileNameBase + JAR_SPLIT + fileNameVersion							+ JAR_SUFFIX;				} else {					return null;				}			} else {				return fileName + JAR_SUFFIX;			}		} else {			return fileName + JAR_SUFFIX;		}	}}