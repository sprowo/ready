package com.prowo.ymlchain.yml.ydnamic;import com.prowo.ymlchain.classloader.DynamicLoader;import com.prowo.ymlchain.classloader.JarFileReader;import com.prowo.ymlchain.classloader.JarVersionManager;import com.prowo.ymlchain.classloader.ShadowClassLoader;import com.prowo.ymlchain.yml.exception.ChainMethodNotFoundException;import com.prowo.ymlchain.yml.exception.YmlClassIlleagleException;import com.prowo.ymlchain.yml.exception.YmlClassNotFoundException;import com.prowo.ymlchain.yml.model.IHandler;import com.prowo.ymlchain.yml.model.IHandlerContext;import org.apache.log4j.Logger;import java.io.*;import java.lang.reflect.Method;import java.util.*;import java.util.concurrent.ConcurrentHashMap;/** * 自定义的classloader，用于加载自定义WEB-INF/shadow/下面的jar */public class YmlClassManager {    private static Logger logger = Logger.getLogger(YmlClassManager.class);    private Map<String, DynamicLoader> loaders = new ConcurrentHashMap<String, DynamicLoader>();    private Map<String, byte[]> classMap = new ConcurrentHashMap<String, byte[]>();    private Map<String, byte[]> resourceMap = new ConcurrentHashMap<String, byte[]>();    private Map<String, Set<String>> ymlFiles = new HashMap<String, Set<String>>();    private Map<String, Class<IHandler>> classInstanceMap = new HashMap<String, Class<IHandler>>();    private Map<String, IHandler> handlerMap = new HashMap<String, IHandler>();    private Map<String, Method> methodMap = new HashMap<String, Method>();    private String loaderName;    public Map<String, Set<String>> getYmlFiles() {        return ymlFiles;    }    private String path = "/";    public String getPath() {        return path;    }    public void setPath(String path) {        this.path = path + "/";    }    /**     * 加载全部jar     */    public void load() {        File file = new File(path);        try {            classInstanceMap.clear();            handlerMap.clear();            methodMap.clear();            ymlFiles.clear();// 20151013 清除缓存，防止yml的hashmap不释放            loaders.clear();//20151018 防止classloader不释放            String[] list = JarVersionManager.getLastVersion(file.list());            if (list != null) {                for (String fileName : list) {                    load0(fileName);                }                if (logger.isDebugEnabled()) {                    logger.debug("path[" + path + "] pass success");                }            } else {                logger.warn("path[" + path + "] is not exsit or no jar file here");            }        } catch (Exception e) {            logger.error("path[" + path + "] access failed", e);        }    }    private void load0(String fileName) {        DynamicLoader loader = loaders.get(fileName);        if (loader != null) {            // 如果是重复加载            loader.unload();            loader = null;            if (logger.isDebugEnabled()) {                logger.debug("JarFile:[" + fileName + "]'s ClassLoader:[" + loader + "] unload success");            }        }        loadJar(fileName);        try {            loader = (DynamicLoader) Class.forName(loaderName).newInstance();        } catch (Exception e1) {            loader = new ShadowClassLoader();        }        loader.setClassFileMap(classMap);        loader.setResourceMap(resourceMap);        // 刷新class缓存        try {            loader.instantiateClass();            loaders.put(fileName, loader);            if (logger.isDebugEnabled()) {                logger.debug("ClassLoader:[" + loader + "]  load JarFile:[" + fileName + "] success");            }        } catch (ClassNotFoundException e) {            logger.error(fileName + " load failed!");        }    }    /**     * 加载一个jar包     *     * @param fileName jar包的文件名     */    public void load(String fileName) {        File file = new File(path);        String newFileName = JarVersionManager.getLastVersion(file.list(), fileName);        if (newFileName == null || !newFileName.equals(fileName)) {            logger.warn("JarFile:[" + fileName + "] is not the latest version,ignore the update");            return;        }        load0(newFileName);    }    /**     * @param name 类名     * @return 类     * @throws ClassNotFoundException     */    public Class<?> findClass(String name) throws ClassNotFoundException {        if (loaders.isEmpty()) {            if (logger.isDebugEnabled()) {                logger.debug("Class:[" + name + "]'s ClassLoader:[" + ShadowClassLoader.getSystemClassLoader() + "]");            }            return Class.forName(name);        }        Class<?> clazz = null;        Collection<DynamicLoader> loaderCollections = loaders.values();        for (DynamicLoader loader : loaderCollections) {            clazz = loader.loadClass(name);            if (clazz != null) {                if (logger.isDebugEnabled()) {                    logger.debug("Class:[" + name + "]'s ClassLoader:[" + loader + "]");                }                return clazz;            }        }        throw new ClassNotFoundException(name);    }    private void loadJar(String jarFileName) {        String fileName = path + jarFileName;        File jarFile = new File(fileName);        InputStream in = null;        try {            in = new BufferedInputStream(new FileInputStream(jarFile));            JarFileReader reader = new JarFileReader(in);            reader.readEntries();            classMap.clear();            classMap.putAll(reader.getClassStreamMap());            resourceMap.clear();            resourceMap.putAll(reader.getResourcesStreamMap());            Set<String> ymlResourceNames = new HashSet<String>();            for (String resourceName : resourceMap.keySet()) {                if (resourceName.endsWith(".yml")) {                    ymlResourceNames.add(resourceName);                }            }            ymlFiles.put(jarFileName, ymlResourceNames);            if (logger.isDebugEnabled()) {                logger.debug("JarFile:[" + fileName + "] load success");            }        } catch (IOException e) {            logger.error("JarFile:[" + fileName + "] load failed", e);        } finally {            if (in != null) {                try {                    in.close();                } catch (IOException e) {                    logger.warn("JarFile:[" + fileName + "] close failed", e);                }            }        }    }    public InputStream getResourceAsStream(String path) {        if (loaders.isEmpty()) {            if (logger.isDebugEnabled()) {                logger.debug("Resource:[" + path + "]'s ClassLoader:[" + ShadowClassLoader.getSystemClassLoader() + "]");            }            return YmlClassManager.class.getResourceAsStream(path);        }        InputStream resourceStream = null;        Collection<DynamicLoader> loaderCollections = loaders.values();        for (DynamicLoader loader : loaderCollections) {            resourceStream = loader.getResourceAsStream(path);            if (resourceStream != null) {                if (logger.isDebugEnabled()) {                    logger.debug("Resource:[" + path + "]'s ClassLoader:[" + loader + "]");                }                break;            }        }        if (resourceStream == null) {            if (logger.isDebugEnabled()) {                logger.debug("Resource:[" + path + "]'s ClassLoader:[" + ShadowClassLoader.getSystemClassLoader() + "]");            }            resourceStream = YmlClassManager.class.getResourceAsStream(path);        }        return resourceStream;    }    public void setLoaderName(String loaderName) {        this.loaderName = loaderName;    }    public String getLoaderName() {        return loaderName;    }    /**     * @throws YmlClassNotFoundException     */    @SuppressWarnings("unchecked")    public Class<IHandler> getHandlerClass(String canonicalName) throws YmlClassNotFoundException {        Class<IHandler> clazz = null;        if (classInstanceMap.get(canonicalName) != null) {            return classInstanceMap.get(canonicalName);        }        try {            clazz = (Class<IHandler>) this.findClass(canonicalName);        } catch (Exception e) {            logger.error(e.getMessage());            throw new YmlClassNotFoundException(canonicalName + " can not be found");        }        classInstanceMap.put(canonicalName, clazz);        return clazz;    }    /**     * @param clazz     * @return     * @throws YmlClassIlleagleException     */    public IHandler getHandler(Class<IHandler> clazz) throws YmlClassIlleagleException {        IHandler handler = null;        if (handlerMap.get(clazz.getCanonicalName()) != null) {            return handlerMap.get(clazz.getCanonicalName());        }        try {            handler = (IHandler) clazz.newInstance();        } catch (Exception e) {            logger.error(e.getMessage());            throw new YmlClassIlleagleException(clazz.getCanonicalName());        }        handlerMap.put(clazz.getCanonicalName(), handler);        return handler;    }    /**     * @param clazz     * @param method_name     * @return     * @throws ChainMethodNotFoundException     */    public Method getMethod(Class<?> clazz, String method_name)            throws ChainMethodNotFoundException {        Method methodObj = null;        String methodKey = clazz.getCanonicalName() + "." + method_name;        if (methodMap.get(methodKey) != null) {            return methodMap.get(methodKey);        }        try {            methodObj = clazz.getMethod(method_name, IHandlerContext.class);        } catch (Exception e) {            throw new ChainMethodNotFoundException(method_name + " is not public or not defined!");        }        methodMap.put(methodKey, methodObj);        return methodObj;    }}